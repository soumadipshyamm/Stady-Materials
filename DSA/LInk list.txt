# Linked Lists in JavaScript - Types & Examples

## Overview of Linked Lists
A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node. Unlike arrays, linked lists don't have indices and allow dynamic memory allocation.

## Types of Linked Lists

### 1. **Singly Linked List**
Each node points only to the next node.

```javascript
// Singly Linked List Implementation
class Node {
  constructor(data) {
    this.data = data;  // Store the value
    this.next = null;  // Pointer to next node (null by default)
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null;  // First node in list (null if empty)
    this.size = 0;     // Track number of nodes
  }

  // Add node at the end
  append(data) {
    const newNode = new Node(data);  // Create new node
    
    if (!this.head) {  // If list is empty
      this.head = newNode;  // Set new node as head
    } else {
      let current = this.head;  // Start at head
      while (current.next) {    // Traverse to last node
        current = current.next;
      }
      current.next = newNode;  // Link last node to new node
    }
    this.size++;  // Increment size counter
  }

  // Insert at specific position
  insertAt(data, index) {
    if (index < 0 || index > this.size) {  // Validate index
      return false;
    }
    
    const newNode = new Node(data);
    
    if (index === 0) {  // Insert at beginning
      newNode.next = this.head;  // New node points to current head
      this.head = newNode;       // Update head to new node
    } else {
      let current = this.head;
      let previous = null;
      let count = 0;
      
      while (count < index) {  // Traverse to position
        previous = current;
        current = current.next;
        count++;
      }
      
      newNode.next = current;    // New node points to current node at index
      previous.next = newNode;   // Previous node points to new node
    }
    
    this.size++;
    return true;
  }

  // Remove node at specific position
  removeAt(index) {
    if (index < 0 || index >= this.size || !this.head) {  // Validate
      return null;
    }
    
    let current = this.head;
    
    if (index === 0) {  // Remove head
      this.head = current.next;  // Set head to next node
    } else {
      let previous = null;
      let count = 0;
      
      while (count < index) {  // Traverse to position
        previous = current;
        current = current.next;
        count++;
      }
      
      previous.next = current.next;  // Bypass node to be removed
    }
    
    this.size--;
    return current.data;  // Return removed data
  }

  // Print all elements
  print() {
    let current = this.head;
    let result = '';
    while (current) {
      result += current.data + ' -> ';
      current = current.next;
    }
    result += 'null';
    console.log(result);
  }
}

// Example Usage
const sll = new SinglyLinkedList();
sll.append(10);     // List: 10 -> null
sll.append(20);     // List: 10 -> 20 -> null
sll.append(30);     // List: 10 -> 20 -> 30 -> null
sll.insertAt(15, 1); // Insert 15 at index 1
sll.print();         // Output: 10 -> 15 -> 20 -> 30 -> null
sll.removeAt(2);     // Remove element at index 2 (20)
sll.print();         // Output: 10 -> 15 -> 30 -> null
```

### 2. **Doubly Linked List**
Each node points to both next and previous nodes.

```javascript
// Doubly Linked List Implementation
class DoublyNode {
  constructor(data) {
    this.data = data;     // Store value
    this.next = null;     // Pointer to next node
    this.prev = null;     // Pointer to previous node
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;     // First node
    this.tail = null;     // Last node
    this.size = 0;        // Node count
  }

  // Add to end
  append(data) {
    const newNode = new DoublyNode(data);
    
    if (!this.head) {            // If list is empty
      this.head = newNode;       // Set as head
      this.tail = newNode;       // And tail
    } else {
      newNode.prev = this.tail;  // New node's prev points to current tail
      this.tail.next = newNode;  // Current tail's next points to new node
      this.tail = newNode;       // Update tail to new node
    }
    
    this.size++;
  }

  // Add to beginning
  prepend(data) {
    const newNode = new DoublyNode(data);
    
    if (!this.head) {            // If list is empty
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;  // New node's next points to current head
      this.head.prev = newNode;  // Current head's prev points to new node
      this.head = newNode;       // Update head to new node
    }
    
    this.size++;
  }

  // Print forward
  printForward() {
    let current = this.head;
    let result = 'null <- ';
    while (current) {
      result += current.data + (current.next ? ' <-> ' : ' -> ');
      current = current.next;
    }
    result += 'null';
    console.log('Forward:  ' + result);
  }

  // Print backward
  printBackward() {
    let current = this.tail;
    let result = 'null <- ';
    while (current) {
      result += current.data + (current.prev ? ' <-> ' : ' -> ');
      current = current.prev;
    }
    result += 'null';
    console.log('Backward: ' + result);
  }
}

// Example Usage
const dll = new DoublyLinkedList();
dll.append(20);      // List: null <- 20 -> null
dll.append(30);      // List: null <- 20 <-> 30 -> null
dll.prepend(10);     // List: null <- 10 <-> 20 <-> 30 -> null
dll.printForward();  // Output: Forward:  null <- 10 <-> 20 <-> 30 -> null
dll.printBackward(); // Output: Backward: null <- 30 <-> 20 <-> 10 -> null
```

### 3. **Circular Linked List**
The last node points back to the first node, forming a circle.

```javascript
// Circular Singly Linked List
class CircularLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  // Add to end
  append(data) {
    const newNode = new Node(data);  // Using same Node class as singly
    
    if (!this.head) {                // If list is empty
      this.head = newNode;
      this.tail = newNode;
      newNode.next = this.head;      // Point to itself (circular)
    } else {
      newNode.next = this.head;      // New node points to head
      this.tail.next = newNode;      // Current tail points to new node
      this.tail = newNode;           // Update tail
    }
    
    this.size++;
  }

  // Print all elements
  print() {
    if (!this.head) {
      console.log('List is empty');
      return;
    }
    
    let current = this.head;
    let result = '';
    let count = 0;
    
    do {  // Use do-while to ensure at least one iteration
      result += current.data + ' -> ';
      current = current.next;
      count++;
    } while (current !== this.head && count < this.size * 2); // Safety check
    
    result += '... (circular)';
    console.log(result);
  }
}

// Example Usage
const cll = new CircularLinkedList();
cll.append(1);    // List: 1 -> (back to 1)
cll.append(2);    // List: 1 -> 2 -> (back to 1)
cll.append(3);    // List: 1 -> 2 -> 3 -> (back to 1)
cll.print();      // Output: 1 -> 2 -> 3 -> ... (circular)
```

### 4. **Doubly Circular Linked List**
Combines features of doubly and circular linked lists.

```javascript
// Doubly Circular Linked List
class DoublyCircularLinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  // Add to end
  append(data) {
    const newNode = new DoublyNode(data);  // Using DoublyNode class
    
    if (!this.head) {                     // If list is empty
      this.head = newNode;
      newNode.next = newNode;             // Point to itself
      newNode.prev = newNode;             // Point to itself
    } else {
      const tail = this.head.prev;        // Last node is head's prev
      
      newNode.next = this.head;           // New node points to head
      newNode.prev = tail;                // New node's prev is old tail
      tail.next = newNode;                // Old tail points to new node
      this.head.prev = newNode;           // Head's prev points to new node
    }
    
    this.size++;
  }

  // Print forward
  print() {
    if (!this.head) {
      console.log('List is empty');
      return;
    }
    
    let current = this.head;
    let result = '... <- ';
    
    do {
      result += current.data + ' <-> ';
      current = current.next;
    } while (current !== this.head);
    
    result += '... (circular)';
    console.log(result);
  }
}

// Example Usage
const dcll = new DoublyCircularLinkedList();
dcll.append(100);  // List: ... <- 100 <-> ... (circular)
dcll.append(200);  // List: ... <- 100 <-> 200 <-> ... (circular)
dcll.append(300);  // List: ... <- 100 <-> 200 <-> 300 <-> ... (circular)
dcll.print();      // Output: ... <- 100 <-> 200 <-> 300 <-> ... (circular)
```

## Comparison Table

| Type | Direction | Memory | Use Cases |
|------|-----------|--------|-----------|
| **Singly Linked** | Forward only | Less | Stacks, simple lists |
| **Doubly Linked** | Forward & Backward | More | Browser history, undo/redo |
| **Circular** | Circular forward | Medium | Round-robin scheduling |
| **Doubly Circular** | Circular both ways | Most | Music playlists, game loops |

## Key Operations Complexity

| Operation | Singly | Doubly | Circular |
|-----------|--------|--------|----------|
| Insert at head | O(1) | O(1) | O(1) |
| Insert at tail | O(n) | O(1) | O(1) |
| Delete at head | O(1) | O(1) | O(1) |
| Delete at tail | O(n) | O(1) | O(n) |
| Search | O(n) | O(n) | O(n) |
| Traverse backward | Not possible | O(n) | O(n) |

## Practical Applications

1. **Singly Linked List**: Implemented in stack, queue, hash table chaining
2. **Doubly Linked List**: Browser back/forward navigation, music player playlists
3. **Circular Linked List**: Round-robin scheduling, multiplayer games
4. **Doubly Circular**: Advanced navigation systems, complex game mechanics


Linked lists are fundamental data structures that form the basis for more complex structures like trees and graphs. Their dynamic nature makes them ideal for scenarios where frequent insertions/deletions are required.



***************************************************************************

// 1. Creating a Node class
class Node {
    constructor(value) {          // 2. constructor runs when making a new Node
        this.value = value;       // 3. store the data/value inside the node
        this.next = null;         // 4. next pointer initially points to nothing
    }
}

// 5. Creating LinkedList class
class LinkedList {
    constructor() {
        this.head = null;         // 6. start of the list (empty at beginning)
    }

    // 7. Insert a new node at the end of the list
    insert(value) {
        const newNode = new Node(value); // 8. create a new node with given value

        if (!this.head) {         // 9. if list is empty
            this.head = newNode;  // 10. new node becomes head
            return;               // 11. exit function
        }

        let current = this.head;  // 12. start from the first node

        while (current.next !== null) { // 13. loop until last node
            current = current.next;     // 14. move to next node
        }

        current.next = newNode;         // 15. attach new node at end
    }

    // 16. Print all values in the list
    print() {
        let current = this.head;        // 17. start from head

        while (current) {               // 18. loop until current becomes null
            console.log(current.value); // 19. print node value
            current = current.next;     // 20. move to next node
        }
    }
}

// 21. Create a linked list
const list = new LinkedList();

// 22. Insert some values
list.insert(10);
list.insert(20);
list.insert(30);

// 23. Print the list
list.print();



***************************************************************************

// Node class (each block in the linked list)
class Node {
    constructor(value) {
        this.value = value;   // data stored
        this.next = null;     // pointer to next node
    }
}

// LinkedList class
class LinkedList {
    constructor() {
        this.head = null;     // first node
    }

    // 1️⃣ Insert at Beginning
    insertAtBeginning(value) {
        const newNode = new Node(value); 
        newNode.next = this.head;  // new node points to previous head
        this.head = newNode;       // update head to new node
    }

    // 2️⃣ Insert at End
    insertAtEnd(value) {
        const newNode = new Node(value);

        if (!this.head) {         // no nodes → new node becomes head
            this.head = newNode;
            return;
        }

        let current = this.head;
        while (current.next) {    // go to last node
            current = current.next;
        }
        current.next = newNode;   // attach at end
    }

    // 3️⃣ Delete Node by Value
    delete(value) {
        if (!this.head) return;                // empty list

        // Case 1: delete head
        if (this.head.value === value) {
            this.head = this.head.next;        // move head
            return;
        }

        // Case 2: delete middle/end node
        let current = this.head;
        while (current.next && current.next.value !== value) {
            current = current.next;
        }

        if (current.next) {                    // value found
            current.next = current.next.next;
        }
    }

    // 4️⃣ Search Node by Value
    search(value) {
        let current = this.head;

        while (current) {
            if (current.value === value) return current; // return node
            current = current.next;
        }
        return null;   // value not found
    }

    // 5️⃣ Reverse Entire Linked List
    reverse() {
        let prev = null;
        let current = this.head;
        let next = null;

        while (current) {
            next = current.next;   // store next node
            current.next = prev;   // reverse pointer
            prev = current;        // move prev forward
            current = next;        // move current forward
        }

        this.head = prev;          // new head
    }

    // 6️⃣ Print Nodes (ref + val)
    print() {
        let current = this.head;

        while (current) {
            console.log({
                ref: current,     // reference (address-like)
                value: current.value
            });
            current = current.next;
        }
    }
}


// -----------------------
// TESTING THE LINKED LIST
// -----------------------

const list = new LinkedList();

// Insert at beginning
list.insertAtBeginning(30);
list.insertAtBeginning(20);
list.insertAtBeginning(10);

// Insert at end
list.insertAtEnd(40);
list.insertAtEnd(50);

// Print list (ref + value)
console.log("Initial List:");
list.print();

// Search for value
console.log("\nSearching for 40:");
console.log(list.search(40));

// Delete node
list.delete(20);
console.log("\nAfter Deleting 20:");
list.print();

// Reverse list
list.reverse();
console.log("\nAfter Reversing:");
list.print();

***************************************************************************

// Node class
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

// Circular Linked List
class CircularLinkedList {
    constructor() {
        this.head = null;
    }

    // 1️⃣ Insert at Beginning
    insertAtBeginning(value) {
        const newNode = new Node(value);

        if (!this.head) {
            this.head = newNode;
            newNode.next = newNode;     // circular link to itself
            return;
        }

        let current = this.head;
        while (current.next !== this.head) {   // go to last node
            current = current.next;
        }

        newNode.next = this.head;   // new node points to old head
        current.next = newNode;     // last node points to new node
        this.head = newNode;        // new node becomes head
    }

    // 2️⃣ Insert at End
    insertAtEnd(value) {
        const newNode = new Node(value);

        if (!this.head) {
            this.head = newNode;
            newNode.next = newNode;
            return;
        }

        let current = this.head;
        while (current.next !== this.head) {
            current = current.next;
        }

        current.next = newNode;
        newNode.next = this.head;   // circle closed
    }

    // 3️⃣ Delete Node by Value
    delete(value) {
        if (!this.head) return;

        let current = this.head;
        let prev = null;

        // Case 1: Deleting head node
        if (current.value === value) {

            // Only 1 node
            if (current.next === this.head) {
                this.head = null;  // list becomes empty
                return;
            }

            // Find last node to fix links
            while (current.next !== this.head) {
                current = current.next;
            }

            current.next = this.head.next; // last → new head
            this.head = this.head.next;    // move head
            return;
        }

        // Case 2: delete non-head node
        prev = this.head;
        current = this.head.next;

        while (current !== this.head && current.value !== value) {
            prev = current;
            current = current.next;
        }

        if (current.value === value) {
            prev.next = current.next;  // bypass the node
        }
    }

    // 4️⃣ Search a Value
    search(value) {
        if (!this.head) return null;

        let current = this.head;

        do {
            if (current.value === value) return current;
            current = current.next;
        } while (current !== this.head);

        return null; // not found
    }

    // 5️⃣ Print (ref + value)
    print() {
        if (!this.head) {
            console.log("List is empty");
            return;
        }

        let current = this.head;

        do {
            console.log({
                ref: current,
                value: current.value
            });
            current = current.next;
        } while (current !== this.head);
    }
}


// --------------------
// TESTING THE LIST
// --------------------

const cll = new CircularLinkedList();

cll.insertAtBeginning(30);
cll.insertAtBeginning(20);
cll.insertAtBeginning(10);

cll.insertAtEnd(40);
cll.insertAtEnd(50);

console.log("Initial Circular List:");
cll.print();

console.log("\nSearching for 40:");
console.log(cll.search(40));

console.log("\nDeleting 20:");
cll.delete(20);
cll.print();

console.log("\nRe-check Circular Loop (stop after few nodes):");
let temp = cll.head;
for (let i = 0; i < 10; i++) {
    console.log(temp.value);
    temp = temp.next;
}


Initial Circular List:
{ ref: Node { value: 10, next: Node }, value: 10 }
{ ref: Node { value: 20, next: Node }, value: 20 }
{ ref: Node { value: 30, next: Node }, value: 30 }
{ ref: Node { value: 40, next: Node }, value: 40 }
{ ref: Node { value: 50, next: Node }, value: 50 }

Searching for 40:
Node { value: 40, next: Node }

Deleting 20:
{ ref: Node { value: 10, next: Node }, value: 10 }
{ ref: Node { value: 30, next: Node }, value: 30 }
{ ref: Node { value: 40, next: Node }, value: 40 }
{ ref: Node { value: 50, next: Node }, value: 50 }



***************************************************************************



// Node for Doubly Circular Linked List
class Node {
    constructor(value) {
        this.value = value;
        this.next = null
        this.prev = null;
    }
}

class DoublyCircularLinkedList {
    constructor() {
        this.head = null;
    }

    // 1️⃣ Insert at Beginning
    insertAtBeginning(value) {
        const newNode = new Node(value);

        // Case: list empty
        if (!this.head) {
            newNode.next = newNode;  // circular link to itself
            newNode.prev = newNode;
            this.head = newNode;
            return;
        }

        const last = this.head.prev; // last node of circular DLL

        newNode.next = this.head;    // new → old head
        newNode.prev = last;         // new → last

        last.next = newNode;         // last → new
        this.head.prev = newNode;    // head.prev → new

        this.head = newNode;         // update head
    }

    // 2️⃣ Insert at End
    insertAtEnd(value) {
        const newNode = new Node(value);

        if (!this.head) {
            newNode.next = newNode;
            newNode.prev = newNode;
            this.head = newNode;
            return;
        }

        const last = this.head.prev;

        newNode.next = this.head;  // new → head
        newNode.prev = last;       // new → last

        last.next = newNode;       // last → new
        this.head.prev = newNode;  // head.prev → new
    }

    // 3️⃣ Delete Node By Value
    delete(value) {
        if (!this.head) return;

        let current = this.head;

        // Loop (circular)
        do {
            if (current.value === value) {

                // If only 1 node
                if (current.next === current && current.prev === current) {
                    this.head = null;
                    return;
                }

                const prevNode = current.prev;
                const nextNode = current.next;

                prevNode.next = nextNode;
                nextNode.prev = prevNode;

                // If deleting head
                if (current === this.head) {
                    this.head = nextNode;
                }

                return;
            }

            current = current.next;

        } while (current !== this.head);
    }

    // 4️⃣ Search Value
    search(value) {
        if (!this.head) return null;

        let current = this.head;

        do {
            if (current.value === value) return current;
            current = current.next;
        } while (current !== this.head);

        return null; // not found
    }

    // 5️⃣ Print All Nodes (ref + value + prev + next)
    print() {
        if (!this.head) {
            console.log("List is empty");
            return;
        }

        let current = this.head;

        do {
            console.log({
                ref: current,
                value: current.value,
                prev: current.prev.value,
                next: current.next.value
            });
            current = current.next;
        } while (current !== this.head);
    }
}


// --------------------
// TESTING THE LIST
// --------------------

const dcll = new DoublyCircularLinkedList();

dcll.insertAtBeginning(30);
dcll.insertAtBeginning(20);
dcll.insertAtBeginning(10);

dcll.insertAtEnd(40);
dcll.insertAtEnd(50);

console.log("Initial Doubly Circular Linked List:");
dcll.print();

console.log("\nSearching for 40:");
console.log(dcll.search(40));

console.log("\nDeleting 20:");
dcll.delete(20);
dcll.print();

console.log("\nDeleting head (10):");
dcll.delete(10);
dcll.print();

Initial Doubly Circular Linked List:
{ ref: Node, value: 10, prev: 50, next: 20 }
{ ref: Node, value: 20, prev: 10, next: 30 }
{ ref: Node, value: 30, prev: 20, next: 40 }
{ ref: Node, value: 40, prev: 30, next: 50 }
{ ref: Node, value: 50, prev: 40, next: 10 }

Searching for 40:
Node { value: 40, next: Node, prev: Node }

Deleting 20:
{ ref: Node, value: 10, prev: 50, next: 30 }
{ ref: Node, value: 30, prev: 10, next: 40 }
{ ref: Node, value: 40, prev: 30, next: 50 }
{ ref: Node, value: 50, prev: 40, next: 10 }
